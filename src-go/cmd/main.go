//go:build linux
// +build linux

package main

import (
	"bytes"
	"ebpf-trackconn/utils"
	"encoding/binary"
	"errors"
	"fmt"
	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/perf"
	"github.com/cilium/ebpf/rlimit"
	"log"
	"os"
	"os/signal"
	"syscall"
	"time"
)

// environment variables is set by scripts/build.sh
//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -cc $BPF_CLANG -cflags $BPF_CLAGS bpf ../../trackconn.ebpf.c -- -I../../headers
func main() {
	stopper := make(chan os.Signal, 1)
	signal.Notify(stopper, os.Interrupt, syscall.SIGTERM, syscall.SIGKILL)

	if err := rlimit.RemoveMemlock(); err != nil {
		log.Fatalf("error when remove memlock: %s \n", err.Error())
	}

	// generated by bpf2go
	cBpfObjs := bpfObjects{}
	if err := loadBpfObjects(&cBpfObjs, nil); err != nil {
		log.Fatalf("error when loading objs: %s \n", err.Error())
	}
	defer cBpfObjs.Close()

	// define trace events reader
	// first: socket event
	socketEvntReader, err := perf.NewReader(cBpfObjs.S_pEvents, os.Getpagesize())
	if err != nil {
		log.Fatalf("create socket event reader failed: %s \n", err.Error())
	}
	defer socketEvntReader.Close()
	// second: connect event
	connectEvntReader, err := perf.NewReader(cBpfObjs.C_pEvents, os.Getpagesize())
	if err != nil {
		log.Fatalf("create connect event reader failed: %s \n", err.Error())
	}
	defer connectEvntReader.Close()

	// link corresponding program to function call
	tp_enter_socket, err := link.Tracepoint("syscalls", "sys_enter_socket",
		cBpfObjs.TracepointSyscallsSysEnterSocket, nil)
	if err != nil {
		log.Fatalf("link enter_socket syscall failed: %s \n", err.Error())
	}
	defer tp_enter_socket.Close()

	tp_enter_connect, err := link.Tracepoint("syscalls", "sys_enter_connect",
		cBpfObjs.TracepointSyscallsSysEnterConnect, nil)
	if err != nil {
		log.Fatalf("link enter_connect syscall failed: %s \n", err.Error())
	}
	defer tp_enter_connect.Close()

	tp_exit_socket, err := link.Tracepoint("syscalls", "sys_exit_socket",
		cBpfObjs.TracepointSyscallsSysExitSocket, nil)
	if err != nil {
		log.Fatalf("link exit_socket syscall failed: %s \n", err.Error())
	}
	defer tp_exit_socket.Close()

	tp_exit_connect, err := link.Tracepoint("syscalls", "sys_exit_connect",
		cBpfObjs.TracepointSyscallsSysExitConnect, nil)
	if err != nil {
		log.Fatalf("link exit_connect syscall failed: %s \n", err.Error())
	}
	defer tp_exit_connect.Close()

	// logger start
	log.Println("Waiting for events...")

	log.SetFlags(log.Lmsgprefix | log.Lshortfile)
	// read from connect event reader
	go func() {
		for {
			recSocket, err := socketEvntReader.Read()
			if err != nil {
				if errors.Is(err, perf.ErrClosed) {
					return
				}
				log.Printf("ERROR: socket event reader failed: %s \n", err.Error())
				continue
			}
			if recSocket.LostSamples != 0 {
				log.Printf("WARN: dropped %d samples due to ring-buffer full \n", recSocket.LostSamples)
				continue
			}
			sEvnt := bpfSocketEvnt{}
			if err := binary.Read(bytes.NewBuffer(recSocket.RawSample), binary.LittleEndian, &sEvnt); err != nil {
				log.Printf("ERROR: read socket event failed: %s \n", err.Error())
			}
			// parsing and show socket event
			parseSocketEvent(&sEvnt)
		}
	}()

	// read from socket event reader
	go func() {
		for {
			recConnect, err := connectEvntReader.Read()
			if err != nil {
				if errors.Is(err, perf.ErrClosed) {
					return
				}
				log.Printf("ERROR: socket event reader failed: %s \n", err.Error())
				continue
			}
			if recConnect.LostSamples != 0 {
				log.Printf("WARN: dropped %d samples due to ring-buffer full \n", recConnect.LostSamples)
				continue
			}
			cEvnt := bpfConnectEvnt{}
			if err := binary.Read(bytes.NewBuffer(recConnect.RawSample), binary.LittleEndian, &cEvnt); err != nil {
				log.Printf("ERROR: read socket event failed: %s \n", err.Error())
			}
			// parsing and show socket event
			parseConnectEvent(&cEvnt)
		}

	}()

	// wait for sigterm or sigkill, block main thread
	<-stopper
	os.Exit(0)
}

// only use fmt.Printf here
func parseSocketEvent(e *bpfSocketEvnt) {
	parseCommon_socket(e)
}

// only use fmt.Printf here
func parseConnectEvent(e *bpfConnectEvnt) {
	parseCommon_connect(e)
}

// internal parse
type EventCommon struct {
	Pid     uint64
	Ppid    uint64
	Uid     uint32
	Comm    [16]int8
	UtsName [65]int8
	Retval  int64
}

func (e *EventCommon) ToString(prefix string) string {
	exeName := utils.I8ToStr(e.Comm[:])
	utsName := utils.I8ToStr(e.UtsName[:])
	execTime := time.Now().UTC().Format(time.RFC3339)
	return fmt.Sprintf("[%s] [%s] [%d (Parent: %d) %s] [%d @ %s] [Ret: %d]",
		prefix, execTime, e.Pid, e.Ppid, exeName, e.Uid, utsName, e.Retval)
}

func parseCommon_socket(e *bpfSocketEvnt) {
	ec := &EventCommon{}
	ec.Pid = e.Pid
	ec.Ppid = e.Ppid
	ec.Uid = e.Uid
	ec.Comm = e.Comm
	ec.UtsName = e.UtsName
	ec.Retval = e.Retval
	fmt.Printf("%s [F:%s] [T:%s] [P:%s] \n", ec.ToString("SOCKET"), utils.ParseSocketFamily(e.Family), utils.ParseSocketType(e.Type), utils.ParseSocketProtocol(e.Protocol))
	return
}

func parseCommon_connect(e *bpfConnectEvnt) {
	ec := &EventCommon{}
	ec.Pid = e.Pid
	ec.Ppid = e.Ppid
	ec.Uid = e.Uid
	ec.Comm = e.Comm
	ec.UtsName = e.UtsName
	ec.Retval = e.Retval
	fmt.Printf("%s [F:%s] [FD: %d] [R: %s:%d] \n", ec.ToString("CONNECT"), utils.ParseSocketFamily(e.Family),
		e.Socketfd, utils.ParseConnectIPAddr(e.Raddr), e.Rport)
	return
}
