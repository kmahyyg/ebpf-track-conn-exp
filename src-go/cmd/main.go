//go:build linux
// +build linux

package main

import (
	"bytes"
	"ebpf-trackconn/utils"
	"encoding/binary"
	"errors"
	"fmt"
	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/perf"
	"github.com/cilium/ebpf/rlimit"
	"log"
	"os"
	"os/signal"
	"syscall"
	"time"
)

// environment variables is set by scripts/build.sh
//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -cc $BPF_CLANG -cflags $BPF_CLAGS bpf ../../trackall.conn.ebpf.gen.c -- -I../../headers
func main() {
	stopper := make(chan os.Signal, 1)
	signal.Notify(stopper, os.Interrupt, syscall.SIGTERM, syscall.SIGKILL)

	if err := rlimit.RemoveMemlock(); err != nil {
		log.Fatalf("error when remove memlock: %s \n", err.Error())
	}

	// this program should only be run > 4.18 kernel, recommended at least 5.2
	// older kernel should not run, since we have to check kernel build kconfig
	// and kernel version, we decided to leave that to our users' choice.

	// generated by bpf2go
	cBpfObjs := bpfObjects{}
	if err := loadBpfObjects(&cBpfObjs, nil); err != nil {
		log.Fatalf("error when loading objs: %s \n", err.Error())
	}
	defer cBpfObjs.Close()

	// define trace events reader
	// first: socket event
	socketEvntReader, err := perf.NewReader(cBpfObjs.S_sEvents, os.Getpagesize())
	if err != nil {
		log.Fatalf("create socket event reader failed: %s \n", err.Error())
	}
	defer socketEvntReader.Close()
	// second: connect event
	connectEvntReader, err := perf.NewReader(cBpfObjs.C_tEvents, os.Getpagesize())
	if err != nil {
		log.Fatalf("create connect event reader failed: %s \n", err.Error())
	}
	defer connectEvntReader.Close()

	// third: sendto event
	sendToEvntReader, err := perf.NewReader(cBpfObjs.StoU_events, os.Getpagesize())
	if err != nil {
		log.Fatalf("create sendto evnt reader failed: %s \n", err.Error())
	}
	defer sendToEvntReader.Close()

	// fourth: recvfrom event
	recvFromEvntReader, err := perf.NewReader(cBpfObjs.RfromU_events, os.Getpagesize())
	if err != nil {
		log.Fatalf("create recvfrom evnt reader failed: %s \n", err.Error())
	}
	defer recvFromEvntReader.Close()

	// link corresponding program to function call
	tp_enter_socket, err := link.Tracepoint("syscalls", "sys_enter_socket",
		cBpfObjs.TracepointSyscallsSysEnterSocket, nil)
	if err != nil {
		log.Fatalf("link enter_socket syscall failed: %s \n", err.Error())
	}
	defer tp_enter_socket.Close()

	tp_enter_connect, err := link.Tracepoint("syscalls", "sys_enter_connect",
		cBpfObjs.TracepointSyscallsSysEnterConnect, nil)
	if err != nil {
		log.Fatalf("link enter_connect syscall failed: %s \n", err.Error())
	}
	defer tp_enter_connect.Close()

	tp_exit_socket, err := link.Tracepoint("syscalls", "sys_exit_socket",
		cBpfObjs.TracepointSyscallsSysExitSocket, nil)
	if err != nil {
		log.Fatalf("link exit_socket syscall failed: %s \n", err.Error())
	}
	defer tp_exit_socket.Close()

	tp_exit_connect, err := link.Tracepoint("syscalls", "sys_exit_connect",
		cBpfObjs.TracepointSyscallsSysExitConnect, nil)
	if err != nil {
		log.Fatalf("link exit_connect syscall failed: %s \n", err.Error())
	}
	defer tp_exit_connect.Close()

	tp_enter_sendto, err := link.Tracepoint("syscalls", "sys_enter_sendto",
		cBpfObjs.TracepointSyscallsSysEnterSendto, nil)
	if err != nil {
		log.Fatalf("link enter_sendto syscall failed: %s \n", err.Error())
	}
	defer tp_enter_sendto.Close()

	tp_exit_sendto, err := link.Tracepoint("syscalls", "sys_exit_sendto",
		cBpfObjs.TracepointSyscallsSysExitSendto, nil)
	if err != nil {
		log.Fatalf("link exit_sendto syscall failed: %s \n", err.Error())
	}
	defer tp_exit_sendto.Close()

	tp_enter_recvfrom, err := link.Tracepoint("syscalls", "sys_enter_recvfrom",
		cBpfObjs.TracepointSyscallsSysEnterRecvfrom, nil)
	if err != nil {
		log.Fatalf("link enter_recvfrom syscall failed: %s \n", err.Error())
	}
	defer tp_enter_recvfrom.Close()

	tp_exit_recvfrom, err := link.Tracepoint("syscalls", "sys_exit_recvfrom",
		cBpfObjs.TracepointSyscallsSysExitRecvfrom, nil)
	if err != nil {
		log.Fatalf("link exit_recvfrom syscall failed: %s \n", err.Error())
	}
	defer tp_exit_recvfrom.Close()

	// logger start
	log.Println("Waiting for events...")

	log.SetFlags(log.Lmsgprefix | log.Lshortfile)
	// read from connect event reader
	go func() {
		for {
			recSocket, err := socketEvntReader.Read()
			if err != nil {
				if errors.Is(err, perf.ErrClosed) {
					return
				}
				log.Printf("ERROR: socket event reader failed: %s \n", err.Error())
				continue
			}
			if recSocket.LostSamples != 0 {
				log.Printf("WARN: dropped %d samples due to ring-buffer full \n", recSocket.LostSamples)
				continue
			}
			sEvnt := bpfSocketEvnt{}
			if err := binary.Read(bytes.NewBuffer(recSocket.RawSample), binary.LittleEndian, &sEvnt); err != nil {
				log.Printf("ERROR: read socket event failed: %s \n", err.Error())
				continue
			}
			// parsing and show socket event
			parseSocketEvent(&sEvnt)
		}
	}()

	// read from socket event reader
	go func() {
		for {
			recConnect, err := connectEvntReader.Read()
			if err != nil {
				if errors.Is(err, perf.ErrClosed) {
					return
				}
				log.Printf("ERROR: socket event reader failed: %s \n", err.Error())
				continue
			}
			if recConnect.LostSamples != 0 {
				log.Printf("WARN: dropped %d samples due to ring-buffer full \n", recConnect.LostSamples)
				continue
			}
			cEvnt := bpfConnectEvnt{}
			if err := binary.Read(bytes.NewBuffer(recConnect.RawSample), binary.LittleEndian, &cEvnt); err != nil {
				log.Printf("ERROR: read socket event failed: %s \n", err.Error())
				continue
			}
			// parsing and show socket event
			parseConnectEvent(&cEvnt)
		}
	}()

	// read from sendto event reader
	go func() {
		for {
			recSendTo, err := sendToEvntReader.Read()
			if err != nil {
				if errors.Is(err, perf.ErrClosed) {
					return
				}
				log.Printf("ERROR: sendto event reader failed: %s \n", err.Error())
				continue
			}
			if recSendTo.LostSamples != 0 {
				log.Printf("WARN: dropped %d samples due to ring-buffer full \n", recSendTo.LostSamples)
				continue
			}
			sEvnt := bpfSendtoEvnt{}
			if err := binary.Read(bytes.NewBuffer(recSendTo.RawSample), binary.LittleEndian, &sEvnt); err != nil {
				log.Printf("ERROR: read sendto event failed: %s \n", err.Error())
				continue
			}
			// parsing and show sendto event
			parseSendtoEvent(&sEvnt)
		}
	}()

	// read from recvfrom event reader
	go func() {
		for {
			recRecvFrom, err := recvFromEvntReader.Read()
			if err != nil {
				if errors.Is(err, perf.ErrClosed) {
					return
				}
				log.Printf("ERROR: recvfrom event reader failed: %s \n", err.Error())
				continue
			}
			if recRecvFrom.LostSamples != 0 {
				log.Printf("WARN: dropped %d samples due to ring-buffer full \n", recRecvFrom.LostSamples)
				continue
			}
			rEvnt := bpfRecvfromEvnt{}
			if err := binary.Read(bytes.NewBuffer(recRecvFrom.RawSample), binary.LittleEndian, &rEvnt); err != nil {
				log.Printf("ERROR: read recvfrom event failed: %s \n", err.Error())
				continue
			}
			// parsing and show recvfrom event
			parseRecvfromEvent(&rEvnt)
		}
	}()

	// wait for sigterm or sigkill, block main thread
	<-stopper
	os.Exit(0)
}

// only use fmt.Printf here, socket
func parseSocketEvent(e *bpfSocketEvnt) {
	parseCommon_socket(e)
}

func parseCommon_socket(e *bpfSocketEvnt) {
	ec := &EventCommon{
		Pid:     e.Pid,
		Ppid:    e.Ppid,
		Uid:     e.Uid,
		Comm:    e.Comm,
		UtsName: e.UtsName,
		Retval:  e.Retval,
	}

	fmt.Printf("%s [F: %s] [T: %s] [P: %s] \n", ec.ToString("SOCKET"), utils.ParseSocketFamily(e.Family),
		utils.ParseSocketType(e.Type), utils.ParseSocketProtocol(e.Protocol))
	return
}

// only use fmt.Printf here, connect
func parseConnectEvent(e *bpfConnectEvnt) {
	parseCommon_connect(e)
}

func parseCommon_connect(e *bpfConnectEvnt) {
	ec := &EventCommon{
		Pid:     e.Pid,
		Ppid:    e.Ppid,
		Uid:     e.Uid,
		Comm:    e.Comm,
		UtsName: e.UtsName,
		Retval:  e.Retval,
	}
	fmt.Printf("%s [F: %s] [FD: %d] [R: %s:%d] \n", ec.ToString("CONNECT"), utils.ParseSocketFamily(e.Family),
		e.Socketfd, utils.ParseConnectIPAddr(e.Raddr), e.Rport)
	return
}

// only use fmt.Printf here, sendto
func parseSendtoEvent(e *bpfSendtoEvnt) {
	parseCommon_sendto(e)
}

func parseCommon_sendto(e *bpfSendtoEvnt) {
	ec := &EventCommon{
		Pid:     e.Pid,
		Ppid:    e.Ppid,
		Uid:     e.Uid,
		Comm:    e.Comm,
		UtsName: e.UtsName,
		Retval:  e.Retval,
	}
	fmt.Printf("%s [F: %s] [R: %s:%d] \n", ec.ToString("SENDTO"), utils.ParseSocketFamily(e.Family),
		utils.ParseConnectIPAddr(e.Raddr), e.Rport)
	return
}

// only use fmt.Printf here, recvfrom
func parseRecvfromEvent(e *bpfRecvfromEvnt) {
	parseCommon_recvfrom(e)
}

func parseCommon_recvfrom(e *bpfRecvfromEvnt) {
	ec := &EventCommon{
		Pid:     e.Pid,
		Ppid:    e.Ppid,
		Uid:     e.Uid,
		Comm:    e.Comm,
		UtsName: e.UtsName,
		Retval:  e.Retval,
	}
	fmt.Printf("%s [F: %s] [S: %s:%d] \n", ec.ToString("RECVFROM"), utils.ParseSocketFamily(e.Family),
		utils.ParseConnectIPAddr(e.Saddr), e.Sport)
	return
}

// internal parse
type EventCommon struct {
	Pid     uint64
	Ppid    uint64
	Uid     uint32
	Comm    [16]int8
	UtsName [65]int8
	Retval  int64
}

func (e *EventCommon) ToString(prefix string) string {
	exeName := utils.I8ToStr(e.Comm[:])
	utsName := utils.I8ToStr(e.UtsName[:])
	execTime := time.Now().UTC().Format(time.RFC3339)
	return fmt.Sprintf("[%s] [%s] [%d (Parent: %d) %s] [%d @ %s] [Ret: %d]",
		prefix, execTime, e.Pid, e.Ppid, exeName, e.Uid, utsName, e.Retval)
}
